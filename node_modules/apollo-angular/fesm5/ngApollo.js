import { __assign, __extends, __decorate, __param } from 'tslib';
import { InjectionToken, NgZone, Optional, Inject, Injectable, Pipe, NgModule } from '@angular/core';
import { ApolloClient } from 'apollo-client';
import { Observable, queueScheduler, observable, from } from 'rxjs';
import { observeOn, startWith } from 'rxjs/operators';

function fromPromise(promiseFn) {
    return new Observable(function (subscriber) {
        promiseFn().then(function (result) {
            if (!subscriber.closed) {
                subscriber.next(result);
                subscriber.complete();
            }
        }, function (error) {
            if (!subscriber.closed) {
                subscriber.error(error);
            }
        });
        return function () { return subscriber.unsubscribe(); };
    });
}
var ZoneScheduler = /** @class */ (function () {
    function ZoneScheduler(zone) {
        this.zone = zone;
        this.now = Date.now ? Date.now : function () { return +new Date(); };
    }
    ZoneScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return this.zone.run(function () {
            return queueScheduler.schedule(work, delay, state);
        });
    };
    return ZoneScheduler;
}());
// XXX: Apollo's QueryObservable is not compatible with RxJS
// TODO: remove it in one of future releases
// https://github.com/ReactiveX/rxjs/blob/9fb0ce9e09c865920cf37915cc675e3b3a75050b/src/internal/util/subscribeTo.ts#L32
function fixObservable(obs) {
    obs[observable] = function () { return obs; };
    return obs;
}
function wrapWithZone(obs, ngZone) {
    return obs.pipe(observeOn(new ZoneScheduler(ngZone)));
}

var QueryRef = /** @class */ (function () {
    function QueryRef(obsQuery, ngZone, options) {
        this.obsQuery = obsQuery;
        var wrapped = wrapWithZone(from(fixObservable(this.obsQuery)), ngZone);
        this.valueChanges = options.useInitialLoading
            ? wrapped.pipe(startWith(__assign(__assign({}, this.obsQuery.getCurrentResult()), { error: undefined, partial: undefined, stale: true })))
            : wrapped;
        this.queryId = this.obsQuery.queryId;
    }
    // ObservableQuery's methods
    QueryRef.prototype.result = function () {
        return this.obsQuery.result();
    };
    QueryRef.prototype.currentResult = function () {
        return this.obsQuery.currentResult();
    };
    QueryRef.prototype.getLastResult = function () {
        return this.obsQuery.getLastResult();
    };
    QueryRef.prototype.getLastError = function () {
        return this.obsQuery.getLastError();
    };
    QueryRef.prototype.resetLastResults = function () {
        return this.obsQuery.resetLastResults();
    };
    QueryRef.prototype.refetch = function (variables) {
        return this.obsQuery.refetch(variables);
    };
    QueryRef.prototype.fetchMore = function (fetchMoreOptions) {
        return this.obsQuery.fetchMore(fetchMoreOptions);
    };
    QueryRef.prototype.subscribeToMore = function (options) {
        // XXX: there's a bug in apollo-client typings
        // it should not inherit types from ObservableQuery
        return this.obsQuery.subscribeToMore(options);
    };
    QueryRef.prototype.updateQuery = function (mapFn) {
        return this.obsQuery.updateQuery(mapFn);
    };
    QueryRef.prototype.stopPolling = function () {
        return this.obsQuery.stopPolling();
    };
    QueryRef.prototype.startPolling = function (pollInterval) {
        return this.obsQuery.startPolling(pollInterval);
    };
    QueryRef.prototype.setOptions = function (opts) {
        return this.obsQuery.setOptions(opts);
    };
    QueryRef.prototype.setVariables = function (variables, tryFetch, fetchResults) {
        if (tryFetch === void 0) { tryFetch = false; }
        if (fetchResults === void 0) { fetchResults = true; }
        return this.obsQuery.setVariables(variables, tryFetch, fetchResults);
    };
    return QueryRef;
}());

var APOLLO_OPTIONS = new InjectionToken('[apollo-angular] options');
var APOLLO_NAMED_OPTIONS = new InjectionToken('[apollo-angular] named options');

var ApolloBase = /** @class */ (function () {
    function ApolloBase(ngZone, _client) {
        this.ngZone = ngZone;
        this._client = _client;
    }
    ApolloBase.prototype.watchQuery = function (options) {
        return new QueryRef(this.ensureClient().watchQuery(__assign({}, options)), this.ngZone, options);
    };
    ApolloBase.prototype.query = function (options) {
        var _this = this;
        return fromPromise(function () {
            return _this.ensureClient().query(__assign({}, options));
        });
    };
    ApolloBase.prototype.mutate = function (options) {
        var _this = this;
        return fromPromise(function () {
            return _this.ensureClient().mutate(__assign({}, options));
        });
    };
    ApolloBase.prototype.subscribe = function (options, extra) {
        var obs = from(fixObservable(this.ensureClient().subscribe(__assign({}, options))));
        return extra && extra.useZone !== true
            ? obs
            : wrapWithZone(obs, this.ngZone);
    };
    /**
     * Get an access to an instance of ApolloClient
     */
    ApolloBase.prototype.getClient = function () {
        return this._client;
    };
    /**
     * Set a new instance of ApolloClient
     * Remember to clean up the store before setting a new client.
     *
     * @param client ApolloClient instance
     */
    ApolloBase.prototype.setClient = function (client) {
        if (this._client) {
            throw new Error('Client has been already defined');
        }
        this._client = client;
    };
    ApolloBase.prototype.ensureClient = function () {
        this.checkInstance();
        return this._client;
    };
    ApolloBase.prototype.checkInstance = function () {
        if (!this._client) {
            throw new Error('Client has not been defined yet');
        }
    };
    return ApolloBase;
}());
var Apollo = /** @class */ (function (_super) {
    __extends(Apollo, _super);
    function Apollo(_ngZone, apolloOptions, apolloNamedOptions) {
        var _this = _super.call(this, _ngZone) || this;
        _this._ngZone = _ngZone;
        _this.map = new Map();
        if (apolloOptions) {
            _this.createDefault(apolloOptions);
        }
        if (apolloNamedOptions && typeof apolloNamedOptions === 'object') {
            for (var name_1 in apolloNamedOptions) {
                if (apolloNamedOptions.hasOwnProperty(name_1)) {
                    var options = apolloNamedOptions[name_1];
                    _this.createNamed(name_1, options);
                }
            }
        }
        return _this;
    }
    /**
     * Create an instance of ApolloClient
     * @param options Options required to create ApolloClient
     * @param name client's name
     */
    Apollo.prototype.create = function (options, name) {
        if (isDefault(name)) {
            this.createDefault(options);
        }
        else {
            this.createNamed(name, options);
        }
    };
    /**
     * Use a default ApolloClient
     */
    Apollo.prototype.default = function () {
        return this;
    };
    /**
     * Use a named ApolloClient
     * @param name client's name
     */
    Apollo.prototype.use = function (name) {
        if (isDefault(name)) {
            return this.default();
        }
        return this.map.get(name);
    };
    /**
     * Create a default ApolloClient, same as `apollo.create(options)`
     * @param options ApolloClient's options
     */
    Apollo.prototype.createDefault = function (options) {
        if (this.getClient()) {
            throw new Error('Apollo has been already created.');
        }
        return this.setClient(new ApolloClient(options));
    };
    /**
     * Create a named ApolloClient, same as `apollo.create(options, name)`
     * @param name client's name
     * @param options ApolloClient's options
     */
    Apollo.prototype.createNamed = function (name, options) {
        if (this.map.has(name)) {
            throw new Error("Client " + name + " has been already created");
        }
        this.map.set(name, new ApolloBase(this._ngZone, new ApolloClient(options)));
    };
    /**
     * Remember to clean up the store before removing a client
     * @param name client's name
     */
    Apollo.prototype.removeClient = function (name) {
        if (isDefault(name)) {
            this._client = undefined;
        }
        else {
            this.map.delete(name);
        }
    };
    Apollo.ctorParameters = function () { return [
        { type: NgZone },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APOLLO_OPTIONS,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APOLLO_NAMED_OPTIONS,] }] }
    ]; };
    Apollo = __decorate([
        Injectable(),
        __param(1, Optional()),
        __param(1, Inject(APOLLO_OPTIONS)),
        __param(2, Optional()),
        __param(2, Inject(APOLLO_NAMED_OPTIONS))
    ], Apollo);
    return Apollo;
}(ApolloBase));
function isDefault(name) {
    return !name || name === 'default';
}

var Query = /** @class */ (function () {
    function Query(apollo) {
        this.apollo = apollo;
        this.client = 'default';
    }
    Query.prototype.watch = function (variables, options) {
        return this.apollo.use(this.client).watchQuery(__assign(__assign({}, options), { variables: variables, query: this.document }));
    };
    Query.prototype.fetch = function (variables, options) {
        return this.apollo.use(this.client).query(__assign(__assign({}, options), { variables: variables, query: this.document }));
    };
    Query.ctorParameters = function () { return [
        { type: Apollo }
    ]; };
    Query = __decorate([
        Injectable()
    ], Query);
    return Query;
}());

var Mutation = /** @class */ (function () {
    function Mutation(apollo) {
        this.apollo = apollo;
        this.client = 'default';
    }
    Mutation.prototype.mutate = function (variables, options) {
        return this.apollo.use(this.client).mutate(__assign(__assign({}, options), { variables: variables, mutation: this.document }));
    };
    Mutation.ctorParameters = function () { return [
        { type: Apollo }
    ]; };
    Mutation = __decorate([
        Injectable()
    ], Mutation);
    return Mutation;
}());

var Subscription = /** @class */ (function () {
    function Subscription(apollo) {
        this.apollo = apollo;
        this.client = 'default';
    }
    Subscription.prototype.subscribe = function (variables, options, extra) {
        return this.apollo.use(this.client).subscribe(__assign(__assign({}, options), { variables: variables, query: this.document }), extra);
    };
    Subscription.ctorParameters = function () { return [
        { type: Apollo }
    ]; };
    Subscription = __decorate([
        Injectable()
    ], Subscription);
    return Subscription;
}());

var SelectPipe = /** @class */ (function () {
    function SelectPipe() {
    }
    SelectPipe.prototype.transform = function (obj, name) {
        if (name === void 0) { name = ''; }
        if (name !== '') {
            return obj && obj.data && obj.data[name];
        }
    };
    SelectPipe = __decorate([
        Pipe({
            name: 'select',
        })
    ], SelectPipe);
    return SelectPipe;
}());

var PROVIDERS = [Apollo];
var DECLARATIONS = [SelectPipe];
var ApolloModule = /** @class */ (function () {
    function ApolloModule() {
    }
    ApolloModule = __decorate([
        NgModule({
            providers: PROVIDERS,
            declarations: DECLARATIONS,
            exports: DECLARATIONS,
        })
    ], ApolloModule);
    return ApolloModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { APOLLO_NAMED_OPTIONS, APOLLO_OPTIONS, Apollo, ApolloBase, ApolloModule, Mutation, Query, QueryRef, SelectPipe, Subscription, PROVIDERS as ɵa, DECLARATIONS as ɵb };
//# sourceMappingURL=ngApollo.js.map
